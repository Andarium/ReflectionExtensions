using System.Linq;
using static ReflectionExtensions.ReflectionExtensions;

namespace ReflectionExtensions.Tests.Generators;

public sealed class TestInstanceFunctionsGenerator : GeneratorBase
{
    protected override string TypeName => "TestInstanceFunctions";

    protected override void GenerateInternal()
    {
        AppendLine("// <auto-generated/>");
        AppendLine("using System;");
        AppendLine("using NUnit.Framework;");
        AppendLine("using static ReflectionExtensions.ReflectionExtensions;");
        AppendLine();
        AppendLine("namespace ReflectionExtensions.Tests;");
        AppendLine();
        AppendLine("[TestFixture]");
        AppendLine($"public sealed class {TypeName}");
        AppendLine("{");

        AppendOffsetLine("[SetUp]");
        AppendOffsetLine($"public void Setup() => {nameof(ReflectionExtensions)}.{nameof(ClearCache)}();");
        AppendLine();

        AppendMethods<int>(5, true);
        AppendLine();
        AppendMethods<string>(5, true);
        AppendLine();
        AppendMethods<int>(5, false);
        AppendLine();
        AppendMethods<string>(5, false);

        Append("}");
    }

    private void AppendMethods<T>(int upToArgs, bool isPublic)
    {
        InvokeSequence(upToArgs + 1, i => AppendInstance<T>(i, isPublic), AppendType.NewLine);
    }

    private void AppendFunName<T>(int args, bool isPublic) => AppendFunName<T>(args, false, isPublic, true);

    private void AppendInstance<T>(int args, bool isPublic)
    {
        const string targetClass = "StubFunctions";
        const string extensionName = nameof(CreateInstanceFunction);

        var testMethodNameBase = "Test_" + GenerateFunName<T>(args, false, isPublic);

        using (WithTestMethodScope<T>(testMethodNameBase + "_Generic"))
        {
            // full generics
            AppendOffset2Line($"var instance = new {targetClass}();");
            AppendOffset2($"var f = {extensionName}");
            AppendGenerics<T>(args + 1, targetClass); // +1 for return type
            Append("(");
            AppendFunName<T>(args, isPublic);
            AppendLine(");");
            AppendInvokeAndAssert<T>(args);
        }

        AppendLine();

        if (args > 0)
        {
            using (WithTestMethodScope<T>(testMethodNameBase + "_A"))
            {
                // generics except type
                AppendOffset2Line($"var instance = new {targetClass}();");
                AppendOffset2($"var f = typeof({targetClass}).{extensionName}A");
                AppendGenerics<T>(args);
                Append("(");
                AppendFunName<T>(args, isPublic);
                AppendLine(");");
                AppendInvokeAndAssert<T>(args);
            }
            
            AppendLine();
            
            using (WithTestMethodScope<T>(testMethodNameBase + "_AR"))
            {
                // generics except type
                AppendOffset2Line($"var instance = new {targetClass}();");
                AppendOffset2($"var f = typeof({targetClass}).{extensionName}AR");
                AppendGenerics<T>(args + 1);
                Append("(");
                AppendFunName<T>(args, isPublic);
                AppendLine(");");
                AppendInvokeAndAssert<T>(args);
            }
            
            AppendLine();
            
                        
            using (WithTestMethodScope<T>(testMethodNameBase + "_TA"))
            {
                // generics except type
                AppendOffset2Line($"var instance = new {targetClass}();");
                AppendOffset2($"var f = {extensionName}TA");
                AppendGenerics<T>(args, targetClass);
                Append("(");
                AppendFunName<T>(args, isPublic);
                AppendLine(");");
                AppendInvokeAndAssert<T>(args);
            }
            
            AppendLine();
        }


        using (WithTestMethodScope<T>(testMethodNameBase + "_T"))
        {
            // full generics
            AppendOffset2Line($"var instance = new {targetClass}();");
            AppendOffset2($"var f = {extensionName}T");
            AppendGenerics<T>(0, targetClass); // +1 for return type
            Append("(");
            AppendFunName<T>(args, isPublic);
            AppendTypeOf<T>(args);
            AppendLine(");");
            AppendInvokeAndAssert<T>(args);
        }

        AppendLine();

        using (WithTestMethodScope<T>(testMethodNameBase + "_R"))
        {
            // R
            AppendOffset2Line($"var instance = new {targetClass}();");
            AppendOffset2($"var f = typeof({targetClass}).{extensionName}R");
            AppendGenerics<T>(1);
            Append("(");
            AppendFunName<T>(args, isPublic);
            AppendTypeOf<T>(args);
            AppendLine(");");
            AppendInvokeAndAssert<T>(args);
        }

        AppendLine();

        using (WithTestMethodScope<T>(testMethodNameBase + "_TR"))
        {
            // TR
            AppendOffset2Line($"var instance = new {targetClass}();");
            AppendOffset2($"var f = {extensionName}TR");
            AppendGenerics<T>(1, targetClass); // +1 for return type
            Append("(");
            AppendFunName<T>(args, isPublic);
            AppendTypeOf<T>(args);
            AppendLine(");");
            AppendInvokeAndAssert<T>(args);
        }

        AppendLine();

        using (WithTestMethodScope<T>(testMethodNameBase + "_X"))
        {
            // X
            AppendOffset2Line($"var instance = new {targetClass}();");
            AppendOffset2($"var f = typeof({targetClass}).{extensionName}X");
            Append("(");
            AppendFunName<T>(args, isPublic);
            AppendTypeOf<T>(args);
            AppendLine(");");
            AppendInvokeAndAssert<T>(args);
        }
    }

    private void AppendInvokeAndAssert<T>(int args)
    {
        // Invoke
        AppendOffset2("var a = f(instance");
        if (args > 0)
        {
            Append(", ");
        }
        AppendParameterValues<T>(args);
        AppendLine(");");

        // Assert
        if (typeof(T) == typeof(string))
        {
            if (args is 0)
            {
                AppendOffset2Line($"Assert.That(a, Is.Null);");
                return;
            }

            var expected = string.Join("", Enumerable.Range(1, args));
            AppendOffset2Line($"Assert.That(a, Is.EqualTo(\"{expected}\"));");
        }
        else
        {
            var expected = args * (args + 1) / 2;
            AppendOffset2Line($"Assert.That(a, Is.EqualTo({expected}));");
        }
    }
}